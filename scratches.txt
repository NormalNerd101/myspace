                            . * - - - - - - * .
1. TLE - multiprocessing - Runtime Checker.
#  multiprocessing lib for constant run-time checking .
@   demonstration : fibonacci calculation : (ANSI added for stimulating effects)

OKPINK = '\033[95m'         # Light pink
OKBLUE = '\033[94m'         # Blue
OKGREEN = '\033[92m'        # Green
WARNING = '\033[93m'        # Yellow
FAIL = '\033[91m'           # Red


import multiprocessing
import time

# fibonacci calculation : memoi
memo = {}
def fib (n):
    if n <= 1 : return n
    if n in memo : return memo[n]

    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]


if __name__ == '__main__':
    # Start bar as a process
    print(OKPINK + "- - - - - - - - - - - - - ")
    print(OKGREEN + "Fibonacci Program starting . . . ")
    time.sleep(1)
    n = int(input(OKBLUE + "Enter random integer value : "))
    p = multiprocessing.Process(target=fib, args=(n,))
    p.start()

    # Wait with program for 3 seconds or until process finishes
    p.join(3)
    # If thread is still active
    if p.is_alive():
        print(FAIL + "Runtime exceeded limit! \n"
              "Terminating . . . ")
        time.sleep(1)
        p.kill()
        print(OKGREEN + "Done!")
    else:
        # Process completed successfully, print the result
        print(OKBLUE + "Process completed successfully. Result:", fib(n))
        print(OKPINK + "- - - - - - - - - - - - - ")


2. The Collatz conjecture. (alas The hailstone seq)
-- reverse :

OKPINK = '\033[95m'         # Light pink

def reversal_collatz(step, y):
    bag = {y}                                                               # 1 is the base
    for _ in range(step):
        bag = {z for x in bag for z in [2*x] + [(x-1) // 3] * (x % 6 == 4)} # conditions

    return sorted(bag)


if __name__ == '__main__':
    print(OKPINK + f"{reversal_collatz(4, 7)}")
                # testCase  --> accurate result : [18, 112]



3. The Pascal triangle
-- colorised for demonstration :

import random

OKPINK = '\033[95m'         # Light pink
OKBLUE = '\033[94m'         # Blue
OKGREEN = '\033[92m'        # Green

#pascal triangle
def generate_pascals_triangle(row):
    triangle = [[1] * (sub + 1) for sub in range(row)]      # set all rows = 1
    for sub in range(2, row):                               # starts from third sub
        for index in range(1, sub):                         # starts from second index
            triangle[sub][index] = triangle[sub - 1][index - 1] + triangle[sub - 1][index]
    return triangle

def random_color(index):
    color = [OKGREEN, OKPINK, OKBLUE]
    return color[index]

def print_pascals_triangle(triangle):
    for row in triangle:
        print(random_color(random.randint(0,2)) + " ".join(map(str, row)).center(len(triangle[-1]) * 2))





4. (...)